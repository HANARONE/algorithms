
from itertools import permutations
def solution(n):
    a = set()
    for i in range(len(n)): #이 반복문은 "numbers" 리스트의 인덱스를 0부터 리스트의 길이 - 1까지 반복합니다.
        a |= set(map(int, map("".join, permutations(list(n), i + 1))))
        #  itertools 모듈의 permutations 함수를 호출하여 "numbers" 리스트의 요소들로부터 i+1개씩 가능한 순열을 생성합니다. 
        # 생성된 순열은 튜플 형태로 반환됩니다.
        # - map 함수를 사용하여 각 순열 튜플에 "".join 함수를 적용합니다. 이는 각 튜플의 요소들을 하나의 문자열로 결합합니다.
        # map 함수를 다시 사용하여 각 문자열 순열을 정수로 변환합니다.
        # 이전 결과에 set 함수를 적용하여 순열로부터 얻은 정수들의 집합을 생성합니다. 중복된 값은 제거됩니다.
        
    a -= set(range(0, 2))
    for i in range(2, int(max(a) ** 0.5) + 1):
        a -= set(range(i * 2, max(a) + 1, i))
    return len(a)
'''
소수의 배수를 지우는 과정에서 중복을 피하기 위함: 만약 range를 2부터 n까지로 설정한다면, 
예를 들어 숫자 4를 처리할 때 2의 배수로 지우고, 이후에 숫자 6을 처리할 때 또 다시 2의 배수로 지우게 됩니다. 
이렇게 되면 중복된 연산이 발생하게 되어 효율성이 떨어집니다. 따라서, range를 2부터 int(n**0.5) + 1까지로 설정하여 중복된 연산을 피할 수 있습니다.
배수를 지울 범위를 최소화하기 위함: range를 2부터 n까지로 설정한다면, n이 아주 큰 경우 매우 많은 연산이 발생하게 됩니다. 
하지만 range를 2부터 int(n**0.5) + 1까지로 설정하면, 배수를 지울 범위를 최소화할 수 있습니다. 이는 소수를 찾는 데 필요한 계산량을 줄여줍니다.
'''